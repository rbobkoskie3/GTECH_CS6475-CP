HOW TO RUN: Open and run 'assignment9_test.py'. Be sure to include the directories 'input', 
'output', and the code 'assignment9.py' in the same WORKING directory as 'assignment9_test.py'.

NOTE: Generating HDR from sample images. (This may take a while.)


================================================
Ellipsis is an object that can appear in slice notation. For example:
myList[1:2, ..., 0]

Its interpretation is purely up to whatever implements the __getitem__ function and sees
Ellipsis objects there, but its main (and intended) use is in the numeric python extension,
which adds a multidimensional array type. Since there are more than one dimensions, slicing
becomes more complex than just a start and stop index; it is useful to be able to slice in
multiple dimensions as well. E.g., given a 4x4 array, the top left area would be defined by
the slice [:2,:2]:

>>> a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12],
       [13, 14, 15, 16]])

>>> a[:2,:2]  # top left
array([[1, 2],
       [5, 6]])

Extending this further, Ellipsis is used here to indicate a placeholder for the rest of the
array dimensions not specified. Think of it as indicating the full slice [:] for all the
dimensions in the gap it is placed, so for a 3d array, a[...,0] is the same as a[:,:,0]
and for 4d, a[:,:,:,0], similarly, a[0,...,0] is a[0,:,:,0] (with however many colons in
the middle make up the full number of dimensions in the array).

Interestingly, in python3, the Ellipsis literal (...) is usable outside the slice syntax, so you can actually write:
>>> ...
Ellipsis


================================================
// Nice example of Python Ellipsis [...].

    num_points = int(pixel_range_max + 1)
    num_channels = images[0].shape[2]

    hdr_image = np.zeros(images[0].shape, dtype=np.float64)

    for channel in range(num_channels):

        # collect the current layer of each input image
        layer_stack = [img[:, :, channel] for img in images]

        # Sample image intensities
        intensity_samples = sampleIntensities(layer_stack, num_points)

        # Compute Response Curves
        response_curve = computeResponseCurve(intensity_samples,
                                              log_exposure_times,
                                              smoothing_lambda,
                                              linearWeight)

        # Build radiance maps
        img_rad_map = computeRadianceMap(layer_stack,
                                         log_exposure_times,
                                         response_curve,
                                         linearWeight)

        # Compose HDR image
        hdr_image[..., channel] = img_rad_map

    # We don't do tone mapping, but here is where it would happen. Some
    # methods work on each layer, others work on the whole image at once;
    # feel free to experiment.    
    output = np.zeros(hdr_image.shape, dtype=np.uint8)
    for i in range(3):
        output[..., i] = normalizeImage(hdr_image[..., i])

    output = output.astype(np.float32)
    